# Команда VK DNS

## Работу выполнили:
Дарья Обрезкова, Наталья Бернштейн, Станислав Добряков

# Лабораторная работа 1

## Описание графа:
Граф содержит выгрузку из пользователей социальной сети ВКонтакте - наших друзей (Бернштейн Натальи, Добрякова Станислава, Обрезковой Дарьи) со связями между ними. Вершинами графа являются пользователи, связь IS_FRIEND обозначает "дружбу" между пользователями.

## Описание методов:
Для сбора данных был использован VK API (https://vk.com/dev/manuals) и язык программирования Python + библиотека py2neo (https://py2neo.org/v4/) для работы с neo4j. Для хранения и визуализации графа использовалась DBMS neo4j.
Граф хранится в виде списка ребер.

### Визуализация в neo4j:
![GitHub Logo](1g.jpg)

![GitHub Logo](2g.jpg)

![GitHub Logo](3g.jpg)

### Часть списка ребер в neo4j:

![GitHub Logo](4g.jpg)

# Лабораторная работа 2

## Выбранный алгоритм: 
Нами был выбран spring-electrical алгоритм. Основной идеей этого алгоритма является то, что граф представляется как электрически заряженные вершины (таким образом, вершины отталкиваются друг от друга электрическими силами), соединенные пружинами. 
Между любой вершиной и ее соседями существует некоторая сила притяжения, вычисляемая по следующей формуле: 
 
![GitHub Logo](5g.jpg)
 
Одновременно между любыми двумя различными вершинами существует отталкивающая сила, формула которой приложена ниже: 

![GitHub Logo](6g.jpg)
 
Здесь x_i обозначает координаты вершины i, а параметр K отвечает за длины ребер в финальном расположении вершин. 
Алгоритм строится следующим образом: 
 1. Исходно точки располагаются произвольным образом 
 2. Для каждой вершины вычисляется сумма действующих на нее сил (как притягивающих, так и отталкивающих) 
 3. Каждая вершина сдвигается в направлении, соответствующем результирующей силе, на некоторое расстояние (step). 
 4. Процесс повторяется, при этом step уменьшается с каждым шагом. 
 5. Процесс заканчивается, когда расположение точек стабилизируется, то есть когда после определенного шага сдвиг вершин не превосходит некоторого порога. 
 
## Реализация: 
Для реализации алгоритма использовался язык Python и Jupyter Notebook. Алгоритму на вход подается граф, хранящийся в виде списков смежности. Написанный код можно найти на github (ссылка указана выше). 
Для визуализации графа с уже найденными координатами использовалась библиотека networkx (https://networkx.github.io (https://networkx.github.io/)), конкретно функция draw_networkx, и библиотека matplotlib (https://matplotlib.org (https://matplotlib.org/)).

Итоговая функция, рисующая граф: **draw_graph**, имеет параметры graph - граф в виде списков смежности, init_step - начальный шаг, K и tol для работы алгоритма визуализации, отвечают за порог сходимости и длину ребер, with_labels_param - добавляет лейблы на визуализацию,  width_param - толщина ребер, alpha_param - прозрачность ребер и вершин, node_color_param - цвет вершин.
 
## Данные и результаты: 
Реализованный алгоритм был протестирован на данных, описанных в лабораторной работе N1, а также на двух меньших графах: 
1. Граф, в котором лишь вершины, соответствующие членам команды VK DNS, соединены с другими вершинами 
2. Граф, в котором оставлены лишь те ребра, одним из концов которых является вершина, имеющая минимум 50 соседей в исходном графе (то есть вершины, имеющие большое количество общих друзей с членами команды VK DNS). 

Результаты и сравнения их с другими методами networkx представлены в папке команды в OneNote и в Jupyter Notebook "Lab 2".

Заметим, что, тогда как в результатах работы нашего алгоритма прослеживается определенная структура расположения точек, она отсутствует в визуализациях, полученных при помощи networkx.draw_circular и networkx.draw_random. При этом на изображениях, полученных при помощи networkx.draw_spectral, точки сливаются друг с другом, затрудняя понимание этой структуры.

# Лабораторная работа 3

### Project name: Организация вечеринки 
 
### Problem statement: 
Организация вечеринки среди друзей из социальной сети Вконтакте 

### Цель проекта: 
Cоставить список друзей, которые будут приглашены на вечеринку. При этом внутри компании обязаны быть 3 главных гостя - ГГ, которые знают друг друга и 12 человек - (кутилы), которые знают всех 3 ГГ.  На вечеринке должны быть и другие люди, которых знает только 1 из ГГ (и не знают кутилы), но с ними каждому гостю можно как-то познакомиться через общих знакомых. 
 
### Software Requirement Specification: 
Для того, чтобы выполнить задание, нам необходимо, чтобы у выбранных ГГ были открытые профили, чтобы мы могли просматривать их друзей для набора остальных гостей на вечеринку. У каждого ГГ должно быть более 12 друзей, при этом у каждого из них также должен быть открытый профиль, чтобы мы могли просмотреть и их друзей.

### Project solutions: 
Чтобы собрать компанию для вечеринки, нам нужно: 
 a Найти ГГ для компании (для них должны выполняться правила из пункта 3) 
 b Найти друзей всех ГГ - множество А 
 c Выбрать подмножество людей размера 12 из множества А, в котором не содержатся ГГ и все люди знают всех ГГ. 
 d Найти для каждого ГГ из его друзей по 5 человек, которых знает только текущий ГГ и не знаю ни остальные ГГ, ни кутилы. 
 e Если какие-то из условий в пункте 3 не выполняется, то мы уменьшаем кол-во человек, которых приглашаем на вечеринку. 
  
### Development tools: 
Для работы алгоритма используется Python3 (Jupyter Notebook), neo4j, NetworkX. 
  
### Algorithms and complexity: 
Линейные и квадратичные алгоритмы (простые вложенные циклы) для сбора информаци (id, друзья, имена и проч.) и формирования графов с помощью встроенных функций NetworkX и neo4j. 
Алгоритм для нахождения кратчайшего пути имеет сложность O(V+ElogV), где V - количество вершин, E - количество ребер. 
 
### Correctness analysis: 
Проверим, работает ли наш алгоритм на полученном в лабораторной N1 датасете, визуализировав данные.
